<!doctype html>
<html lang="tr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zinciri Kırma Metodolojisi</title>

  <style>
    /* ========= Genel tema ve değişkenler ========= */
    :root {
      --border: #000;
      --muted: #666;
      --cell-width: 72px;
      --cell-height: 72px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      /* Genel arka plan ve varsayılan dış boşluk */
      background-color: #e4e4e4;
      margin: 10px;
    }

    /* ========= Form satırları / layout ========= */
    .row {
      display: flex;
      gap: 40px;
      flex-wrap: wrap;
      align-items: flex-end;
      margin-top: 12px;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-weight: 600;
    }

    input[type="text"],
    input[type="date"],
    select {
      border-radius: 6px;
      border: 2px solid var(--border);
      padding: 8px;
      background: #fff;
      min-width: 200px;
    }

    #chainName {
      width: 420px;
    }

    .firstRowOption {
      height: 37px;
    }

    .error {
      color: #c00;
      font-weight: 700;
    }

    /* Tarih geçişlerini görsel olarak ayırmak için sol tarafta ay / yıl çizgileri */
    .month-break-left {
      border-left: 3px dashed #4c794c !important;
    }

    .year-break-left {
      border-left: 9px double #d45454 !important;
    }

    /* ========= Butonlar ========= */
    button {
      border: 5px inset var(--border);
      background: #fff;
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 700;
    }

    button:hover {
      background: #f2f2f2;
    }

    .muted {
      color: var(--muted);
    }

    /* ========= Haftalık gün seçimleri ========= */
    .checkboxes {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .checkboxes label {
      flex-direction: row;
      gap: 10px;
      font-weight: 500;
    }

    .preInfo {
      margin-left: 30px;
      color: #a8316d;
      font-size: 12pt;
    }

    /* ========= Zincir kartı (her hedef için) ========= */
    .chain {
      margin-top: 15px;
      border: ridge #34df89c4 10px;
      padding: 15px;
      background: #84d4847a;
      align-items: center;
    }

    .chain-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .chain-title {
      font-weight: 800;
      font-size: 16pt;
    }

    .chain-actions {
      display: flex;
      gap: 8px;
    }

    /* ========= Grid / tablo sarmalayıcıları ========= */
    .grid-wrap {
      overflow-x: auto;
      overflow-y: hidden;
      max-width: 100%;
    }

    .grid-outer {
      display: flex;
      flex-direction: column;
      max-width: 100%;
    }

    .grid-scroll-top {
      overflow-x: auto;
      overflow-y: hidden;
      max-width: 100%;
    }

    .grid-scroll-inner {
      height: 1px;
    }

    /* ========= Tablo genel görünüm ========= */
    table {
      border-collapse: collapse;
      background: #fff;
      width: max-content;
      min-width: max-content;
      table-layout: fixed;
    }

    th,
    td {
      border: 1.5px solid var(--border);
      width: var(--cell-width);
      height: var(--cell-height);
      position: relative;
      text-align: center;
      vertical-align: middle;
      padding: 0;
      overflow: hidden;
    }

    th {
      background: #312d2d23;
      font-weight: 800;
      font-size: 12px;
    }

    /* Zincir tablosunun en üst başlık satırı (gün isimleri) */
    .chain table tr:first-child th {
      height: 36px;
      line-height: 36px;
      padding-top: 0;
      padding-bottom: 0;
    }

    /* Sol taraftaki yıl/ay başlık hücreleri */
    .rowhead {
      width: auto;
      min-width: calc(0.75 * var(--cell-width));
      padding: 0 8px;
      white-space: nowrap;
      font-size: 12px;
    }

    /* Hücre içi küçük tarih etiketi (gün sayısı) */
    .datebadge {
      position: absolute;
      left: 4px;
      top: 4px;
      font-size: 11px;
      color: #333;
    }

    .dayname {
      font-size: 11px;
    }

    .cell {
      cursor: pointer;
      user-select: none;
    }

    /* SVG ile çizilen X işaretinin kapsayıcısı */
    .x-mark {
      margin-top: 10px;
      margin-left: 10px;
      width: calc(100% - 10px);
      height: calc(100% - 10px);
      pointer-events: none;
      display: block;
    }

    /* Boş kalan hücreler (tarih olmayan alanlar) */
    .empty {
      background: #a8a4a4;
    }

    /* ========= Grid boyutlandırma (satır / sütun) alanı ========= */
    .sizeInput {
      /* Grid boyutu giriş satırı (satır/sütun) */
      margin-top: 32px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    /* ========= Zincir sekmeleri ========= */
    .chain-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      border-bottom: 2px solid #0c5816;
      margin-top: 10px;
    }

    .chain-tab {
      padding: 6px 12px;
      border: 2px solid #0c5816;
      border-bottom: none;
      background: #ddd;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      font-size: 13px;
    }

    .chain-tab.active {
      background: #fff;
      border-color: #000;
      font-weight: 700;
    }

    .chain-container {
      margin: 0;
    }

    .chain-container .chain {
      margin-top: 0;
    }

    /* Font Awesome ikonları için boyut */
    i {
      font-size: 16px;
    }

    /* ========= Responsive eklemeler (ChatGPT) ========= */

    /* Sayfanın kenarlardan boşluklu olması için genel body boşluğu */
    .app-frame {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* İç içerik alanı: küçük ekranlarda sola yapışmayı engellemek için yumuşak padding */
    .app-inner {
      padding-right: 0;
      padding-top: 10px;
      padding-bottom: 10px;
    }

    /* Grid boyutu sayı alanları için tutarlı görünüm */
    .sizeInput input[type="number"] {
      border-radius: 6px;
      border: 2px solid var(--border);
      padding: 4px 6px;
      width: 80px;
      background: #fff;
    }

    /* Küçük ekranlarda (mobil) fazla yatay boşlukları azalt, elemanların satıra sığmasını sağla */
    @media (max-width: 600px) {
      .app-inner {
        margin-left: 0 !important;
      }

      .row {
        gap: 16px;
        margin-top: 8px;
      }

      .row label {
        flex: 1 1 100%;
      }

      .checkboxes {
        gap: 8px;
      }

      .firstRowOption,
      #chainName {
        width: 100%;
        max-width: 100%;
      }

      .sizeInput {
        gap: 8px;
      }

      .preInfo {
        margin-left: 0;
        font-size: 11pt;
      }

      .total-ring-box {
        width: 100% !important;
      }


    }

    /* Tablet aralığında da geniş elemanların konteynere oturmasını sağla */
    @media (min-width: 601px) and (max-width: 1024px) {
      .app-inner {
        margin-left: 0 !important;
      }

      .total-ring-box {
        width: 100% !important;
      }

      #chainName {
        width: 100%;
        max-width: 100%;
      }
    }

    /* ========= Responsive eklemeler sonu ========= */

    /* ========= Özel düzenlemeler: toplam halka kutusu & aksiyon butonları ========= */

    /* Toplam halka kutusu: içindeki 3 elemanı yatay/dikey ortala, metni sar */
    .total-ring-box {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
    }

    /* Aksiyon butonları genel düzeni (masaüstü varsayılan) */
    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: center;
    }

    .action-buttons button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 16px;
    }

    .action-buttons .btn-text {
      display: inline-flex;
      gap: 4px;
    }

    .action-buttons .btn-text-word {
      display: inline;
    }

    /* Mobil ve tablet: dış body margin 5px olsun */
    @media (max-width: 1024px) {
      body {
        margin: 5px;
      }
    }

    /* Mobil: butonlar içerik kadar genişlik alsın, ikon üstte, kelimeler alt alta;
         sığarsa yana yana, sığmazsa alt alta gelsin. Ayrıca toplam halka kutusu altında boşluk bırak. */
    @media (max-width: 600px) {
      .action-buttons {
        margin-left: 5px !important;
        margin-right: 5px !important;
        gap: 12px;
        justify-content: flex-start;
      }

      .action-buttons button {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-left: 0 !important;
        margin-right: 0 !important;
        min-width: auto;
      }

      .action-buttons .btn-text {
        flex-direction: column;
        align-items: center;
      }

      .action-buttons .btn-text-word {
        display: block;
      }

      .total-ring-box {
        margin-bottom: 16px;
      }

      .app-frame {
        padding-left: 8px;
        padding-right: 8px;
        box-sizing: border-box;
      }

    }
  </style>

  <!-- Font Awesome ikonları (sil, ekle vs. ikonlar için) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" />
</head>

<body>
  <!-- Dış çerçeve: uygulamanın ana kutusu -->
  <div class="app-frame" style="
        border: outset 16px rgb(146, 192, 223);
        border-radius: 10px;
        background-color: #ceeaf5;
      ">
    <div class="app-inner" style="margin-left: 50px">
      <h1 style="color: rgb(230, 4, 4); margin-top: 30px">Zinciri Kırma!</h1>

      <!-- Hedef adı ve tarih aralığı girişi -->
      <div class="row">
        <label>
          Hedefim:
          <input id="chainName" type="text" maxlength="75" placeholder="Örnek: Her gün 1 saat kitap okuyacağım!"
            class="firstRowOption" />
        </label>

        <label>
          Başlangıç tarihi:
          <input id="startDate" type="date" class="firstRowOption" />
        </label>

        <label>
          Bitiş tarihi:
          <input id="endDate" type="date" class="firstRowOption" />
        </label>
      </div>

      <!-- Hedef ismi hatası -->
      <div id="nameError" class="error" style="display: none; margin-top: 10px"></div>

      <!-- Tarih hatası -->
      <div id="dateError" class="error" style="display: none; margin-top: 10px; margin-left: 468px"></div>

      <!-- Haftanın hangi günleri seçilecek? -->
      <label style="margin-top: 32px">Haftada hangi günler?</label>

      <div class="row">
        <div class="checkboxes" id="weekdayBox">
          <label>
            <input type="checkbox" id="wd0" checked />
            Pazartesi
          </label>
          <label>
            <input type="checkbox" id="wd1" checked />
            Salı
          </label>
          <label>
            <input type="checkbox" id="wd2" checked />
            Çarşamba
          </label>
          <label>
            <input type="checkbox" id="wd3" checked />
            Perşembe
          </label>
          <label>
            <input type="checkbox" id="wd4" checked />
            Cuma
          </label>
          <label>
            <input type="checkbox" id="wd5" checked />
            Cumartesi
          </label>
          <label>
            <input type="checkbox" id="wd6" checked />
            Pazar
          </label>

          <!-- Tüm günler seçili olduğunda gösterilen mor bilgi notu -->
          <label id="allSelectedNote" class="preInfo">
            Varsayılan olarak
            <span style="text-decoration-line: underline">tüm günler</span>
            seçili.
          </label>
        </div>

        <!-- Gün seçimi hatası (checkbox satırının altında) -->
        <div id="weekdayError" class="error" style="display: none; margin-top: 10px"></div>

        <!-- Seçilen gün sayısına göre toplam halka bilgisi -->
        <div class="total-ring-box" style="
              font-size: 24pt;
              background-color: #d1cfcfbd;
              border-radius: 32px;
              padding: 12px;
              gap: inherit;
            ">
          <strong style="color: rgb(24, 156, 30); margin-left: 12px; display: inline-block">
            Toplam halka:
          </strong>
          <span id="count" style="
                color: rgb(153, 115, 33);
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-weight: bolder;
              ">
            0
          </span>
          (zincirin içerdiği gün sayısı)
        </div>
      </div>

      <!-- Grid boyutu için satır / sütun girişleri -->
      <div class="sizeInput">
        <label>Satır:</label>
        <input type="number" id="rowsInput" min="1" step="1" max="" />
        <label>Sütun:</label>
        <input type="number" id="colsInput" min="1" step="1" max="" />
        <span class="preInfo" id="layoutInfo"></span>
      </div>
    </div>

    <!-- Aksiyon butonları: zincir oluştur / içe aktar / yedek indir -->
    <div class="action-buttons" style="
          margin-top: 50px;
          margin-left: 50px;
          margin-bottom: 50px;
        ">
      <button id="btnAddChain" title="Seçtiğiniz niteliklere göre zinciri oluşturmak için hemen tıklayın!">
        <i class="fa-solid fa-plus"></i>
        <span class="btn-text">
          <span class="btn-text-word">Zinciri</span>
          <span class="btn-text-word">oluştur!</span>
        </span>
      </button>

      <button id="btnLoadFromFile" title="Bilgisayarınızdan ana sunucuya dosya aktarımı"
        style="margin-left: 125px; margin-right: 25px">
        <i class="fa-solid fa-folder-plus"></i>
        <span class="btn-text">
          <span class="btn-text-word">Karşıya</span>
          <span class="btn-text-word">yükle</span>
        </span>
      </button>

      <button id="btnExportFallback"
        title="Aşağıda var olan tüm tablolarınızın .zincir uzantılı (JSON formatında) verilerin yedeği">
        <i class="fa-solid fa-download"></i>
        <span class="btn-text">
          <span class="btn-text-word">Yedek</span>
          <span class="btn-text-word">indir</span>
        </span>
      </button>
    </div>
  </div>

  <!-- Oluşturulmuş zincir kartlarının gösterileceği alan -->
  <div id="chainsList"></div>

  <!-- Dosyadan içe aktarma için gizli input -->
  <input type="file" id="fileInput" accept="application/json" style="display: none" />

  <script type="text/javascript">
    (function () {
      'use strict';

      /* ============================================================
       *  KÜÇÜK YARDIMCI FONKSİYONLAR
       *  - DOM seçici
       *  - Tarih formatlayıcılar
       *  - ID üretici
       * ========================================================== */

      /**
       * Kısa selector yardımcısı
       * @param {string} sel - CSS selector
       * @param {HTMLElement} [root=document] - Arama yapılacak kök eleman
       */
      function qs(sel, root) {
        return (root || document).querySelector(sel);
      }

      /**
       * Date nesnesini "YYYY-MM-DD" formatına çevirir
       */
      function toISO(d) {
        var y = d.getFullYear();
        var m = String(d.getMonth() + 1).padStart(2, '0');
        var day = String(d.getDate()).padStart(2, '0');
        return y + '-' + m + '-' + day;
      }

      /**
       * Date nesnesini TR yerel tarihi olarak "GG.AA.YYYY" formatında döndürür
       * (kartların üst kısmındaki tarih aralığı için kullanılıyor)
       */
      function fmtTR(d) {
        return d.toLocaleDateString('tr-TR', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
        });
      }

      /**
       * Haftanın gün isimleri (Pazartesi başlangıçlı)
       */
      var DAY_NAMES = [
        'Pazartesi',
        'Salı',
        'Çarşamba',
        'Perşembe',
        'Cuma',
        'Cumartesi',
        'Pazar',
      ];

      /**
       * Zincirin oluşturulma tarihini okunabilir biçimde üretir.
       * Örn: "01.01.2025 09:30 (GMT+3)"
       */
      function formatNowLocal_DDMMYYYY_HHMM_GMT() {
        var d = new Date();
        var GG = String(d.getDate()).padStart(2, '0');
        var AA = String(d.getMonth() + 1).padStart(2, '0');
        var YYYY = d.getFullYear();
        var SS = String(d.getHours()).padStart(2, '0');
        var DD = String(d.getMinutes()).padStart(2, '0');
        var tz = -d.getTimezoneOffset() / 60;
        var sign = tz >= 0 ? '+' : '-';
        var tzStr = 'GMT' + sign + Math.abs(tz);
        return GG + '.' + AA + '.' + YYYY + ' ' + SS + ':' + DD + ' (' + tzStr + ')';
      }

      /**
       * localStorage anahtar ismi.
       * Her şey tek bir JSON nesnesi olarak burada tutuluyor.
       */
      var STORE_KEY = 'dont-break-v6';

      /**
       * Basit rastgele ID üretici
       * Örn: c3jf8hs1
       */
      function rid() {
        return 'c' + Math.random().toString(36).slice(2, 10);
      }

      /* ============================================================
       *  VERİ DEPOLAMA (localStorage)
       *  - getStore / setStore
       *  - dışarıdan içe aktarılan verilerle birleştirme
       * ========================================================== */

      /**
       * localStorage içinden zincirleri okur.
       * Dönüş:
       * {
       *   order: [id1, id2, ...],  // sekme sırası
       *   items: {
       *     [id]: {
       *       id, name, cfg, dates, marks, created
       *     }
       *   }
       * }
       */
      function getStore() {
        try {
          var raw = localStorage.getItem(STORE_KEY);
          if (!raw) return { order: [], items: {} };

          var obj = JSON.parse(raw);
          return {
            order: obj.order || Object.keys(obj.items || {}),
            items: obj.items || {},
          };
        } catch (e) {
          // Herhangi bir parse hatasında boş store dönüyoruz
          return { order: [], items: {} };
        }
      }

      /**
       * Verilen store nesnesini JSON olarak localStorage'a yazar.
       */
      function setStore(s) {
        localStorage.setItem(STORE_KEY, JSON.stringify(s));
      }

      /**
       * Mevcut store ile dışarıdan içe aktarılan store'u birleştirir.
       * - Var olan zincirler silinmez, yeniler sona eklenir.
       * - ID çakışması olursa yeni rastgele ID atanır.
       */
      function mergeStores(current, imported) {
        if (!imported || !imported.items) return current;

        var result = {
          order: current.order.slice(),
          items: Object.assign({}, current.items),
        };

        var importedOrder = imported.order || Object.keys(imported.items || {});

        for (var i = 0; i < importedOrder.length; i++) {
          var oldId = importedOrder[i];
          var ch = imported.items[oldId];
          if (!ch) continue;

          // ID çakışmasını engelle (aynı ID zaten varsa yenisini üret)
          var newId = oldId;
          if (result.items[newId]) {
            newId = rid();
          }

          ch.id = newId;
          result.items[newId] = ch;
          result.order.push(newId);
        }

        return result;
      }

      /* ============================================================
       *  FORM ELEMANLARI ve GLOBAL DURUM
       * ========================================================== */

      var chainName = qs('#chainName');
      var startDate = qs('#startDate');
      var endDate = qs('#endDate');
      var countEl = qs('#count');
      var colsInput = qs('#colsInput');
      var rowsInput = qs('#rowsInput');
      var layoutInfo = qs('#layoutInfo');
      var listEl = qs('#chainsList');

      // Hangi zincirin aktif sekmede açık olduğunu tutar
      var activeChainId = null;

      // Grid hesaplamalarında kullanılacak satır/sütun sayıları
      var cols;
      var rows;
      var n; // zincirdeki toplam tarih sayısı

      /* ============================================================
       *  HAFTALIK GÜN SEÇİMİ (checkbox'lar)
       * ========================================================== */

      /**
       * Checkbox'lardan seçili günleri okur.
       * Dönüş: [Pazartesi'den Pazara boolean dizi]
       */
      function readSelectedWeekdays() {
        var out = [];
        for (var i = 0; i < 7; i++) {
          var el = document.getElementById('wd' + i);
          out.push(el ? !!el.checked : true);
        }
        return out;
      }

      /**
       * Seçili gün sayısını (kaç adet true) döndürür.
       */
      function countSelectedWeekdays(picked) {
        var c = 0;
        for (var i = 0; i < 7; i++) {
          if (picked[i]) c++;
        }
        return c;
      }

      /**
       * Gün seçimindeki bilgilendirme ve hata mesajını günceller.
       * - Hiç gün yoksa: mor bilgi gizlenir, kırmızı hata gösterilir.
       * - Tüm günler seçiliyse: mor bilgi gösterilir.
       * - Arada bir seçim ise: ikisi de gizlenir.
       */
      function updateAllSelectedNote() {
        var note = document.getElementById('allSelectedNote');
        var weekdayErr = document.getElementById('weekdayError');
        if (!note || !weekdayErr) return;

        var picked = readSelectedWeekdays();
        var nSelected = countSelectedWeekdays(picked);

        weekdayErr.style.display = 'none';
        weekdayErr.textContent = '';

        if (nSelected === 0) {
          note.style.display = 'none';
          weekdayErr.textContent = 'Lütfen en az bir gün seçin.';
          weekdayErr.style.display = 'block';
        } else if (nSelected === 7) {
          note.style.display = 'block';
          note.innerHTML =
            'Varsayılan olarak <span style="text-decoration-line:underline;">tüm günler</span> seçili.';
          weekdayErr.style.display = 'none';
        } else {
          note.style.display = 'none';
        }
      }

      /* ============================================================
       *  TARİH HESAPLARI
       *  - İki tarih arasındaki günler
       *  - Haftanın belirli günlerine filtreleme
       * ========================================================== */

      /**
       * İki tarih arasındaki tüm günleri (başlangıç ve bitiş dahil) Date dizisi olarak döndürür.
       */
      function daysBetween(s, e) {
        var S = new Date(s);
        var E = new Date(e);

        // S > E ise yer değiştir
        if (E < S) {
          var t = S;
          S = E;
          E = t;
        }

        var out = [];
        var cur = new Date(S.getFullYear(), S.getMonth(), S.getDate());
        var last = new Date(E.getFullYear(), E.getMonth(), E.getDate());

        for (var d = new Date(cur); d <= last; d.setDate(d.getDate() + 1)) {
          out.push(new Date(d));
        }
        return out;
      }

      /**
       * Verilen Date dizisini, seçili haftalık günlere göre filtreler.
       * picked: [Pzt..Paz] boolean dizi.
       */
      function filterByWeekdays(arr, picked) {
        return arr.filter(function (d) {
          // JS'te getDay() Pazar=0 olduğu için, Pazartesi=0 olacak şekilde kaydırıyoruz.
          return picked[(d.getDay() + 6) % 7];
        });
      }

      /* ============================================================
       *  GRID (SATIR / SÜTUN) HESAPLAMALARI
       * ========================================================== */

      /**
       * Seçili gün sayısına göre layout konfigürasyonunu hesaplar.
       * - stepCols: sütunlar arasındaki adım (seçili gün sayısı kadar)
       * - minCols: minimum sütun sayısı
       * - maxCols: maksimum sütun sayısı (toplam gün sayısı kadar)
       */
      function getLayoutConfig(nSelected) {
        var stepCols = nSelected && nSelected > 0 ? nSelected : 1;
        var minCols = stepCols;
        var maxCols = n && n > 0 ? n : stepCols;
        if (maxCols < minCols) maxCols = minCols;
        return { stepCols: stepCols, minCols: minCols, maxCols: maxCols };
      }

      /**
       * Verilen konfigürasyona göre izin verilen sütun sayıları listesini üretir.
       * Örneğin:
       *   minCols=2, maxCols=10, step=2 => [2,4,6,8,10]
       */
      function getAllowedColsList(cfg) {
        var list = [];
        var c = cfg.minCols;
        while (c <= cfg.maxCols) {
          list.push(c);
          c += cfg.stepCols;
        }
        if (list.length === 0) {
          list.push(cfg.maxCols);
        } else if (list[list.length - 1] !== cfg.maxCols) {
          list.push(cfg.maxCols);
        }
        return list;
      }

      /**
       * Satır / sütun input'larının min/max değerlerini ve açıklama metnini günceller.
       */
      function syncLayoutInputs(nSelected) {
        var cfg = getLayoutConfig(nSelected);
        var colsMin = cfg.minCols;
        var colsMax = cfg.maxCols;

        // Henüz gün sayısı yoksa inputları boş bırakıyoruz.
        if (!n || n <= 0) {
          colsInput.min = colsMin;
          colsInput.max = colsMax;
          colsInput.step = 1;
          colsInput.setAttribute('min', String(colsMin));
          colsInput.setAttribute('max', String(colsMax));
          colsInput.setAttribute('step', '1');
          colsInput.value = '';

          rowsInput.min = 1;
          rowsInput.max = 1;
          rowsInput.step = 1;
          rowsInput.setAttribute('min', '1');
          rowsInput.setAttribute('max', '1');
          rowsInput.setAttribute('step', '1');
          rowsInput.value = '';

          layoutInfo.textContent = '';
          return;
        }

        if (!cols || cols < colsMin) cols = colsMin;
        if (cols > colsMax) cols = colsMax;

        var rowsMin = 1;
        var rowsMax = Math.ceil(n / colsMin);
        if (!rows || rows < rowsMin) rows = rowsMin;
        if (rows > rowsMax) rows = rowsMax;

        colsInput.min = colsMin;
        colsInput.max = colsMax;
        colsInput.step = 1;
        colsInput.setAttribute('min', String(colsMin));
        colsInput.setAttribute('max', String(colsMax));
        colsInput.setAttribute('step', '1');
        colsInput.value = String(cols);

        rowsInput.min = rowsMin;
        rowsInput.max = rowsMax;
        rowsInput.step = 1;
        rowsInput.setAttribute('min', String(rowsMin));
        rowsInput.setAttribute('max', String(rowsMax));
        rowsInput.setAttribute('step', '1');
        rowsInput.value = String(rows);

        layoutInfo.textContent = n
          ? 'Düzen: ' +
          rows +
          ' satır × ' +
          cols +
          ' sütun = ' +
          rows * cols +
          ' toplam hücre (Son satırda boş hücreler olabilir.)'
          : '';
      }

      /**
       * Seçili gün sayısına ve aday sütun sayısına göre en uygun sütunu seçer,
       * satır sayısını buna göre günceller.
       */
      function computeLayoutFromColsAbsolute(nSelected, colsCandidate) {
        var cfg = getLayoutConfig(nSelected);
        var allowed = getAllowedColsList(cfg);

        var cand = parseInt(colsCandidate, 10);
        if (!cand || cand < cfg.minCols) cand = cfg.minCols;
        if (cand > cfg.maxCols) cand = cfg.maxCols;

        var chosen = allowed[0];
        if (cand <= allowed[0]) {
          chosen = allowed[0];
        } else if (cand >= allowed[allowed.length - 1]) {
          chosen = allowed[allowed.length - 1];
        } else {
          for (var i = 0; i < allowed.length; i++) {
            if (allowed[i] >= cand) {
              chosen = allowed[i];
              break;
            }
          }
        }

        cols = chosen;
        rows = Math.ceil(n / cols);
      }

      /**
       * Başlangıç–bitiş tarihi veya gün seçimi değiştiğinde toplam gün sayısını
       * (n) ve grid düzenini yeniden hesaplar.
       */
      function updateCount() {
        var s = startDate.value;
        var e = endDate.value;

        if (!s || !e) {
          n = 0;
          countEl.textContent = '0';
          layoutInfo.textContent = '';
          syncLayoutInputs(0);
          return;
        }

        var picked = readSelectedWeekdays();
        var nSelected = countSelectedWeekdays(picked);

        n = filterByWeekdays(
          daysBetween(new Date(s + 'T00:00:00'), new Date(e + 'T00:00:00')),
          picked
        ).length;

      
          cols = 1;
          rows = n;
          let bestDiff = Infinity;

          // Özel durum: n <= nSelected ise
          if (nSelected > 0 && n <= nSelected) {
            cols = nSelected;
            rows = Math.ceil(n / cols);
          }
          else {
            // Normal durum → optimum grid bul
            let c = 1;
            while (c <= n) {
              if (nSelected === 0 || c % nSelected === 0) {
                let r = Math.ceil(n / c);
                let diff = Math.abs(r - c);

                if (
                  diff < bestDiff ||
                  (diff === bestDiff && c > cols)
                ) {
                  bestDiff = diff;
                  cols = c;
                  rows = r;
                }
              }
              c++;
            }
          }

          // Varsayılanları inputlara yaz
          colsInput.value = cols;
          rowsInput.value = rows;


        countEl.textContent = String(n);

        if (!n || n <= 0) {
          cols = 0;
          rows = 0;
          syncLayoutInputs(nSelected);
          return;
        }

        computeLayoutFromColsAbsolute(nSelected, cols);
        syncLayoutInputs(nSelected);
        countEl.textContent = String(n);
      }




      /**
       * Sütun input'u (colsInput) değiştiğinde çağrılır.
       * İzin verilen sütun listesi içinde en yakın değeri seçer.
       */
      function updateCols() {
        if (!n) return;

        var picked = readSelectedWeekdays();
        var nSelected = countSelectedWeekdays(picked);
        var cfg = getLayoutConfig(nSelected);
        var allowed = getAllowedColsList(cfg);

        var prev = typeof cols === 'number' && cols > 0 ? cols : allowed[0];

        var raw = parseInt(colsInput.value, 10);
        if (isNaN(raw)) raw = prev;

        var dir = 0;
        if (raw > prev) dir = +1;
        else if (raw < prev) dir = -1;

        var newCols;

        if (dir === 0) {
          if (raw <= allowed[0]) {
            newCols = allowed[0];
          } else if (raw >= allowed[allowed.length - 1]) {
            newCols = allowed[allowed.length - 1];
          } else {
            newCols = allowed[0];
            for (var i = 0; i < allowed.length; i++) {
              if (allowed[i] >= raw) {
                newCols = allowed[i];
                break;
              }
            }
          }
        } else {
          var idx = 0;
          for (var j = 0; j < allowed.length; j++) {
            if (allowed[j] <= prev) idx = j;
          }
          idx += dir;
          if (idx < 0) idx = 0;
          if (idx >= allowed.length) idx = allowed.length - 1;
          newCols = allowed[idx];
        }

        cols = newCols;
        rows = Math.ceil(n / cols);

        syncLayoutInputs(nSelected);
        countEl.textContent = String(n);
      }

      /**
       * Satır input'u (rowsInput) değiştiğinde çağrılır.
       * Mümkün olan satır sayıları arasından en uygun kombinasyonu (rows, cols) seçer.
       */
      function updateRows() {
        if (!n) return;

        var picked = readSelectedWeekdays();
        var nSelected = countSelectedWeekdays(picked);
        var cfg = getLayoutConfig(nSelected);
        var allowed = getAllowedColsList(cfg);

        var prevRows = rows || 1;
        var prevCols = cols || allowed[0];

        var rowsMin = 1;
        var rowsMax = Math.ceil(n / cfg.minCols);

        var raw = parseInt(rowsInput.value, 10);
        if (!raw || raw < rowsMin) raw = rowsMin;
        if (raw > rowsMax) raw = rowsMax;

        var dir = 0;
        if (raw > prevRows) dir = +1;
        else if (raw < prevRows) dir = -1;

        // Her sütun seçeneği için kaç satır gerektiğini listele
        var rowsOptions = [];
        for (var i = 0; i < allowed.length; i++) {
          var r = Math.ceil(n / allowed[i]);
          if (rowsOptions.indexOf(r) === -1) rowsOptions.push(r);
        }
        rowsOptions.sort(function (a, b) {
          return a - b;
        });

        var targetRows = prevRows;

        if (dir > 0) {
          for (var i2 = 0; i2 < rowsOptions.length; i2++) {
            if (rowsOptions[i2] > prevRows) {
              targetRows = rowsOptions[i2];
              break;
            }
          }
        } else if (dir < 0) {
          for (var i3 = rowsOptions.length - 1; i3 >= 0; i3--) {
            if (rowsOptions[i3] < prevRows) {
              targetRows = rowsOptions[i3];
              break;
            }
          }
        } else {
          // Yön yoksa, girilen değere en yakın satırı bul
          var best = rowsOptions[0];
          var bestDiff = Math.abs(best - raw);
          for (var i4 = 1; i4 < rowsOptions.length; i4++) {
            var diff = Math.abs(rowsOptions[i4] - raw);
            if (diff < bestDiff) {
              bestDiff = diff;
              best = rowsOptions[i4];
            }
          }
          targetRows = best;
        }

        // Hedef satır sayısına uygun sütun sayısını bul
        var bestCols = null;
        var bestDiffCols = Infinity;
        for (var k = 0; k < allowed.length; k++) {
          var c = allowed[k];
          var rVal = Math.ceil(n / c);
          if (rVal === targetRows) {
            var diffCols = Math.abs(c - prevCols);
            if (diffCols < bestDiffCols) {
              bestDiffCols = diffCols;
              bestCols = c;
            }
          }
        }

        if (bestCols == null) {
          var baseCols = Math.ceil(n / targetRows);
          if (baseCols < cfg.minCols) baseCols = cfg.minCols;
          if (baseCols > cfg.maxCols) baseCols = cfg.maxCols;
          bestCols = allowed[allowed.length - 1];
          for (var kk = 0; kk < allowed.length; kk++) {
            if (allowed[kk] >= baseCols) {
              bestCols = allowed[kk];
              break;
            }
          }
        }

        cols = bestCols;
        rows = targetRows;

        syncLayoutInputs(nSelected);
        countEl.textContent = String(n);
      }

      /* ============================================================
       *  OLAY BAĞLANTILARI (FORM ve CHECKBOXLAR)
       * ========================================================== */

      startDate.addEventListener('change', function () {
        updateCount();
        updateAllSelectedNote();
      });
      startDate.addEventListener('input', function () {
        updateCount();
        updateAllSelectedNote();
      });
      endDate.addEventListener('change', function () {
        updateCount();
        updateAllSelectedNote();
      });
      endDate.addEventListener('input', function () {
        updateCount();
        updateAllSelectedNote();
      });

      colsInput.addEventListener('input', updateCols);
      rowsInput.addEventListener('input', updateRows);

      // Haftalık gün checkbox'larına dinleyici ekle
      (function () {
        for (var i = 0; i < 7; i++) {
          var el = document.getElementById('wd' + i);
          if (el) {
            var handler = function () {
              updateCount();
              updateAllSelectedNote();
            };
            el.addEventListener('change', handler);
            el.addEventListener('input', handler);
          }
        }
      })();

      /* ============================================================
       *  ZİNCİRLERİN GÖRSEL OLARAK RENDER EDİLMESİ
       *  - Sekmeler (tabs)
       *  - Kartlar
       *  - Tablo yapısı
       * ========================================================== */

      /**
       * Tüm zincirleri localStorage'dan okuyup sekmeler ve kartları oluşturur.
       */
      function renderAll() {
        var s = getStore();
        listEl.innerHTML = '';

        if (!s.order.length) {
          activeChainId = null;
          return;
        }

        var tabsBar = document.createElement('div');
        tabsBar.className = 'chain-tabs';

        var container = document.createElement('div');
        container.className = 'chain-container';

        var firstId = null;

        for (var i = 0; i < s.order.length; i++) {
          var id = s.order[i];
          var ch = s.items[id];
          if (!ch) continue;

          if (!firstId) firstId = id;

          // Her zincir için sekme butonu
          var tab = document.createElement('button');
          tab.className = 'chain-tab';
          tab.dataset.id = id;

          var label = 'Zincir ' + (i + 1);
          tab.textContent = label;

          tab.addEventListener(
            'click',
            (function (cid) {
              return function () {
                setActiveChain(cid);
              };
            })(id)
          );

          tabsBar.appendChild(tab);

          // Zincire ait kartı oluştur
          var card = renderCard(ch);
          card.style.display = 'none';
          container.appendChild(card);
        }

        listEl.appendChild(tabsBar);
        listEl.appendChild(container);

        // Aktif ID yoksa ilk zinciri aktif yap
        if (!activeChainId || !s.items[activeChainId]) {
          activeChainId = firstId;
        }
        setActiveChain(activeChainId);
      }

      /**
       * Verilen zinciri aktif sekme olarak işaretler ve ilgili kartı gösterir.
       */
      function setActiveChain(id) {
        activeChainId = id;

        var tabs = listEl.querySelectorAll('.chain-tab');
        for (var i = 0; i < tabs.length; i++) {
          var tab = tabs[i];
          if (tab.dataset.id === id) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        }

        var cards = listEl.querySelectorAll('.chain');
        for (var j = 0; j < cards.length; j++) {
          var card = cards[j];
          if (card.dataset.id === id) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        }
      }

      /**
       * Tek bir zincir için kart HTML'ini oluşturur.
       * Başlık, tarih aralığı, sil butonu ve tablo grid'ini içerir.
       */
      function renderCard(ch) {
        var card = document.createElement('section');
        card.className = 'chain';
        card.dataset.id = ch.id;

        var head = document.createElement('div');
        head.className = 'chain-head';

        var left = document.createElement('div');

        // Zincir başlığı
        var title = document.createElement('div');
        title.className = 'chain-title';
        title.textContent = ch.name || 'Zincir';

        // Tarih aralığı alt başlık
        var sub = document.createElement('div');
        sub.className = 'muted';
        sub.textContent =
          fmtTR(new Date(ch.cfg.start + 'T00:00:00')) +
          ' – ' +
          fmtTR(new Date(ch.cfg.end + 'T00:00:00'));

        left.appendChild(title);
        left.appendChild(sub);

        // Oluşturulma tarihi bilgisi
        if (ch.created) {
          var createdInfo = document.createElement('div');
          createdInfo.className = 'muted';
          createdInfo.textContent = 'Oluşturulma: ' + ch.created;
          left.appendChild(createdInfo);
        }

        // Zincir silme butonu
        var actions = document.createElement('div');
        actions.className = 'chain-actions';

        var del = document.createElement('button');

        // Sil ikonunun <i> etiketi
        var icon = document.createElement('i');
        icon.className = 'fa fa-trash';

        // Yazı için <span> (italik olmaması için)
        var text = document.createElement('span');
        text.textContent = ' Zinciri sil';

        del.appendChild(icon);
        del.appendChild(text);
        del.addEventListener('click', function () {
          delChain(ch.id);
        });
        actions.appendChild(del);

        head.appendChild(left);
        head.appendChild(actions);
        card.appendChild(head);

        // Tabloyu yatay kaydırma ile sarmalayan yapı
        var outer = document.createElement('div');
        outer.className = 'grid-outer';

        var topScroll = document.createElement('div');
        topScroll.className = 'grid-scroll-top';

        var topInner = document.createElement('div');
        topInner.className = 'grid-scroll-inner';
        topScroll.appendChild(topInner);

        var wrap = document.createElement('div');
        wrap.className = 'grid-wrap';
        wrap.appendChild(buildTable(ch));

        outer.appendChild(topScroll);
        outer.appendChild(wrap);
        card.appendChild(outer);

        setupGridScrollSync(outer);

        return card;
      }

      /**
       * Zincir için tarih tablosunu (grid) oluşturur.
       * - İlk satır: yıl ve gün isimleri
       * - İlk sütun: ilgili satırdaki ay isimleri (ör. Ocak / Şubat)
       * - Hücre içi: gün numarası + X işareti (varsa)
       */
      function buildTable(ch) {
        var table = document.createElement('table');
        var cols = ch.cfg.cols;
        var rows = ch.cfg.rows;
        var N = ch.dates.length;

        var picked = ch.cfg.picked || [true, true, true, true, true, true, true];

        // Seçili gün indeksleri ve isimleri (Pzt..Paz)
        var selectedDayIndices = [];
        var selectedDayNames = [];
        for (var di = 0; di < 7; di++) {
          if (picked[di]) {
            selectedDayIndices.push(di);
            selectedDayNames.push(DAY_NAMES[di]);
          }
        }

        // Hiç seçili yoksa güvenli tarafta kalmak için tüm günleri kullan
        if (selectedDayIndices.length === 0) {
          for (var k0 = 0; k0 < 7; k0++) {
            selectedDayIndices.push(k0);
            selectedDayNames.push(DAY_NAMES[k0]);
          }
        }

        var k = selectedDayIndices.length;

        // Gün isimlerini, ilk tarihin haftalık konumuna göre döndür
        var orderedDayNames = selectedDayNames.slice();
        if (N > 0 && k > 0) {
          var firstDate = new Date(ch.dates[0]);
          var wd0 = (firstDate.getDay() + 6) % 7;
          var pos = -1;
          for (var t = 0; t < selectedDayIndices.length; t++) {
            if (selectedDayIndices[t] === wd0) {
              pos = t;
              break;
            }
          }
          if (pos !== -1) {
            orderedDayNames = [];
            for (var ii = 0; ii < k; ii++) {
              orderedDayNames.push(selectedDayNames[(pos + ii) % k]);
            }
          }
        }

        // -------- Başlık satırı (yıl + gün isimleri) --------
        var tr1 = document.createElement('tr');

        var pad = document.createElement('th');
        pad.className = 'rowhead';
        var firstYear = N > 0 ? new Date(ch.dates[0]).getFullYear() : '';
        pad.textContent = firstYear;
        tr1.appendChild(pad);

        for (var c = 0; c < cols; c++) {
          var th = document.createElement('th');
          th.className = 'dayname';
          if (k > 0) {
            th.textContent = orderedDayNames[c % k];
          } else {
            th.textContent = '';
          }
          tr1.appendChild(th);
        }

        table.appendChild(tr1);

        // -------- Veri satırları (her satır için ilgili ay isimleri + günler) --------
        for (var r = 0; r < rows; r++) {
          var tr = document.createElement('tr');

          // Sol başlık: bu satırda bulunan ay isimleri
          var rh = document.createElement('th');
          rh.className = 'rowhead';
          var startIdx = r * cols;
          var endIdx = Math.min(startIdx + cols, N);
          var labels = [];

          for (var i = startIdx; i < endIdx; i++) {
            var iso = ch.dates[i];
            if (!iso) continue;
            var nm = new Date(iso).toLocaleDateString('tr-TR', { month: 'long' });
            if (labels.indexOf(nm) === -1) labels.push(nm);
          }
          rh.textContent = labels.length ? labels.join(' / ') : '';
          tr.appendChild(rh);

          // Hücreler: her hücre bir günü temsil eder ya da boş olur
          for (var c2 = 0; c2 < cols; c2++) {
            var td = document.createElement('td');
            td.className = 'cell';

            var idx = r * cols + c2;

            if (idx < N) {
              var dd = new Date(ch.dates[idx]);

              // Hücre içi küçük tarih (günün numarası)
              var badge = document.createElement('div');
              badge.className = 'datebadge';
              badge.textContent = String(dd.getDate());
              td.appendChild(badge);

              // Tooltip: tam tarih + gün adı
              td.title = dd.toLocaleDateString('tr-TR', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
              });

              td.dataset.id = ch.id;
              td.dataset.idx = String(idx);

              // Eğer bu güne daha önce X işareti konmuşsa tekrar render et
              if (ch.marks && ch.marks[idx]) {
                td.appendChild(makeX());
              }

              // Hücre tıklanınca X işaretini aç/kapat
              td.addEventListener('click', onCellClick);

              // Ay ve yıl geçişlerinde hücrenin soluna özel çizgi ekle
              if (idx > 0) {
                var prev = new Date(ch.dates[idx - 1]);
                if (prev.getFullYear() !== dd.getFullYear()) {
                  td.classList.add('year-break-left');
                } else if (prev.getMonth() !== dd.getMonth()) {
                  td.classList.add('month-break-left');
                }
              }
            } else {
              // Bu satırda tarih kalmadıysa boş hücre (gri)
              td.classList.add('empty');
            }

            tr.appendChild(td);
          }

          table.appendChild(tr);
        }

        return table;
      }

      /**
       * Tablo kısmı ile üstteki ince kaydırma barını senkronize eder.
       * Böylece kullanıcı hem yukarıdan hem tablonun kendisinden kaydırabilir.
       */
      function setupGridScrollSync(outer) {
        var top = outer.querySelector('.grid-scroll-top');
        var inner = outer.querySelector('.grid-scroll-inner');
        var wrap = outer.querySelector('.grid-wrap');
        var table = wrap ? wrap.querySelector('table') : null;

        if (!top || !inner || !wrap || !table) return;

        function syncWidth() {
          inner.style.width = table.scrollWidth + 'px';
        }
        syncWidth();

        top.addEventListener('scroll', function () {
          wrap.scrollLeft = top.scrollLeft;
        });
        wrap.addEventListener('scroll', function () {
          top.scrollLeft = wrap.scrollLeft;
        });

        // Boyut değişimlerini yakalamak için ResizeObserver kullan
        if (window.ResizeObserver) {
          var ro = new ResizeObserver(syncWidth);
          ro.observe(table);
        } else {
          window.addEventListener('resize', syncWidth);
        }
      }

      /* ============================================================
       *  HÜCRE TIKLAMA ve X İŞARETİ
       * ========================================================== */

      /**
       * Hücreye tıklandığında çağrılır.
       * - Eğer X işareti varsa kaldırır, yoksa ekler.
       * - Değişiklikleri localStorage'daki ilgili zincire yazar.
       */
      function onCellClick(ev) {
        var td = ev.currentTarget;
        var id = td.dataset.id;
        var idx = td.dataset.idx;
        var s = getStore();
        var ch = s.items[id];
        if (!ch) return;

        var has = td.querySelector('svg.x-mark');
        if (has) {
          has.remove();
          if (ch.marks) delete ch.marks[idx];
        } else {
          if (!ch.marks) ch.marks = {};
          ch.marks[idx] = 1;
          td.appendChild(makeX());
        }

        setStore(s);
      }

      /**
       * Tek bir hücre için SVG tabanlı X işareti oluşturur.
       * Hafif titreşimli (jitter) çizgilerle daha doğal bir görünüm elde edilir.
       */
      function makeX() {
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'x-mark');
        svg.setAttribute('viewBox', '0 0 100 100');
        svg.setAttribute('preserveAspectRatio', 'none');
        svg.setAttribute('fill', 'none');

        function jitter() {
          return (Math.random() - 0.5) * 8;
        }

        function curve(a, b) {
          var mid = [(a[0] + b[0]) / 2 + jitter(), (a[1] + b[1]) / 2 + jitter()];
          var c1 = [(a[0] * 2 + mid[0]) / 3 + jitter(), (a[1] * 2 + mid[1]) / 3 + jitter()];
          var c2 = [(b[0] * 2 + mid[0]) / 3 + jitter(), (b[1] * 2 + mid[1]) / 3 + jitter()];
          return (
            'M ' +
            a[0] +
            ',' +
            a[1] +
            ' C ' +
            c1[0] +
            ',' +
            c1[1] +
            ' ' +
            c2[0] +
            ',' +
            c2[1] +
            ' ' +
            b[0] +
            ',' +
            b[1]
          );
        }

        var p1 = document.createElementNS(svg.namespaceURI, 'path');
        p1.setAttribute('d', curve([12, 12], [88, 88]));
        p1.setAttribute('stroke', 'black');
        p1.setAttribute('stroke-width', '8');
        p1.setAttribute('stroke-linecap', 'round');
        p1.setAttribute('stroke-opacity', '0.9');

        var p2 = document.createElementNS(svg.namespaceURI, 'path');
        p2.setAttribute('d', curve([88, 12], [12, 88]));
        p2.setAttribute('stroke', 'black');
        p2.setAttribute('stroke-width', '8');
        p2.setAttribute('stroke-linecap', 'round');
        p2.setAttribute('stroke-opacity', '0.9');

        svg.appendChild(p1);
        svg.appendChild(p2);
        return svg;
      }

      /* ============================================================
       *  ZİNCİR SİLME
       * ========================================================== */

      /**
       * Belirtilen ID'li zinciri localStorage'dan siler ve ekranı günceller.
       */
      function delChain(id) {
        if (!confirm('Bu zinciri tamamen silmek istediğinize emin misiniz?')) return;
        var s = getStore();
        delete s.items[id];
        s.order = s.order.filter(function (x) {
          return x !== id;
        });
        setStore(s);
        renderAll();
      }

      /* ============================================================
       *  YENİ ZİNCİR OLUŞTURMA
       * ========================================================== */

      qs('#btnAddChain').addEventListener('click', function () {
        var sVal = startDate.value;
        var eVal = endDate.value;

        var nameErr = document.getElementById('nameError');
        var dateErr = document.getElementById('dateError');
        if (nameErr) {
          nameErr.style.display = 'none';
          nameErr.textContent = '';
        }
        if (dateErr) {
          dateErr.style.display = 'none';
          dateErr.textContent = '';
        }

        // Zincir adı zorunlu
        if (!chainName.value || chainName.value.trim() === '') {
          if (nameErr) {
            nameErr.textContent = 'Lütfen zincir adını girin.';
            nameErr.style.display = 'block';
          }
          chainName.focus();
          return;
        }

        // Tarih kontrolü
        if (!sVal || !eVal || new Date(eVal) < new Date(sVal)) {
          if (dateErr) {
            dateErr.textContent = 'Bitiş tarihi, başlangıç tarihinden önce olamaz.';
            dateErr.style.display = 'block';
          }
          endDate.focus();
          return;
        }

        var picked = readSelectedWeekdays();
        var nSelected = countSelectedWeekdays(picked);

        // Hiç gün seçilmediyse zinciri oluşturma, kullanıcıyı uyar.
        if (nSelected === 0) {
          updateAllSelectedNote();
          return;
        }

        // Seçilen tarih aralığını, haftalık seçime göre filtrele
        var dates = filterByWeekdays(
          daysBetween(new Date(sVal + 'T00:00:00'), new Date(eVal + 'T00:00:00')),
          picked
        ).map(function (d) {
          return toISO(d) + 'T00:00:00';
        });

        var N = dates.length;
        if (N === 0) {
          alert('Seçime uyan gün yok.');
          return;
        }

        // Kullanıcının seçtiği satır / sütun değerleri
        var colsVal = parseInt(colsInput.value, 10);
        var rowsVal = parseInt(rowsInput.value, 10);

        var ch = {
          id: rid(),
          name: (chainName.value || 'Zincir').trim(),
          cfg: { start: sVal, end: eVal, picked: picked, rows: rowsVal, cols: colsVal },
          dates: dates,
          marks: {},
          created: formatNowLocal_DDMMYYYY_HHMM_GMT(),
        };

        var st = getStore();
        st.items[ch.id] = ch;
        st.order.push(ch.id);
        setStore(st);
        renderAll();

        // Zincir oluşturulduktan sonra formu sıfırla
        chainName.value = '';

        var now = new Date();
        startDate.value = toISO(now);
        var later = new Date(now);
        later.setDate(later.getDate() + 36);
        endDate.value = toISO(later);

        ['wd0', 'wd1', 'wd2', 'wd3', 'wd4', 'wd5', 'wd6'].forEach(function (id) {
          var el = document.getElementById(id);
          if (el) el.checked = true;
        });

        updateCount();
        updateAllSelectedNote();
      });

      /* ============================================================
       *  DOSYADAN YÜKLEME (İÇE AKTARMA)
       * ========================================================== */

      /**
       * Dosya seçerek zincirleri içe aktarma işlemini başlatır.
       * - Desteklenen format: .zincir uzantılı JSON
       * - showOpenFilePicker varsa onu kullanır, yoksa <input type="file"> ile çalışır.
       */
      function loadFromFile() {
        if (window.showOpenFilePicker) {
          window
            .showOpenFilePicker({
              types: [
                {
                  description: 'Zincir Dosyası',
                  accept: { 'application/json': ['.zincir'] },
                },
              ],
            })
            .then(function (res) {
              return res[0].getFile();
            })
            .then(function (file) {
              return file.text();
            })
            .then(function (text) {
              var obj = JSON.parse(text);
              if (!obj || !obj.items) throw new Error('Beklenen şema yok');

              // Mevcut store'u koruyarak SONUNA ekle
              var current = getStore();
              var merged = mergeStores(current, obj);
              setStore(merged);
              renderAll();
              alert('Dosyadan zincirler eklendi (mevcut liste korunarak).');
            })
            .catch(function (err) {
              if (!(err && err.name === 'AbortError')) {
                alert('Dosyadan yükleme hatası: ' + err.message);
              }
            });
        } else {
          // Eski tarayıcılar için yedek yöntem
          var fi = document.getElementById('fileInput');
          if (fi) {
            fi.setAttribute('accept', '.zincir');
          }
          document.getElementById('fileInput').click();
        }
      }

      qs('#btnLoadFromFile').addEventListener('click', loadFromFile);

      /* ============================================================
       *  YEDEK İNDİRME (DIŞA AKTARMA)
       * ========================================================== */

      /**
       * Tüm store'u JSON olarak indirir (.zincir uzantılı).
       */
      qs('#btnExportFallback').addEventListener('click', function () {
        var blob = new Blob([JSON.stringify(getStore(), null, 2)], {
          type: 'application/json',
        });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Yeni Hedefler.zincir';
        a.click();
        URL.revokeObjectURL(url);
      });

      /**
       * Gizli <input type="file"> üzerinden içe aktarma (showOpenFilePicker yoksa kullanılır).
       */
      document.getElementById('fileInput').addEventListener('change', function (e) {
        var f = e.target.files[0];
        if (!f) return;

        if (!/\.zincir$/i.test(f.name)) {
          alert('Lütfen .zincir uzantılı bir dosya seçin.');
          e.target.value = '';
          return;
        }

        var r = new FileReader();
        r.onload = function () {
          try {
            var obj = JSON.parse(r.result);
            if (!obj.items) throw new Error('Şema yok');

            // Mevcut store'u koruyarak SONUNA ekle
            var current = getStore();
            var merged = mergeStores(current, obj);
            setStore(merged);
            renderAll();
            alert('İçe aktarıldı (mevcut liste korunarak).');
          } catch (err) {
            alert('Zincir dosyası okunamadı: ' + err.message);
          }
        };
        r.readAsText(f);
        e.target.value = '';
      });

      /* ============================================================
       *  BAŞLANGIÇ DURUMU (DEFAULT DEĞERLER)
       * ========================================================== */

      var today = new Date();
      startDate.value = toISO(today);
      var t2 = new Date(today);
      t2.setDate(t2.getDate() + 36);
      endDate.value = toISO(t2);

      var fi0 = document.getElementById('fileInput');
      if (fi0) {
        fi0.setAttribute('accept', '.zincir');
      }

      // İlk açılışta sayıları ve layout'u üret
      updateCount();
      renderAll();
      updateAllSelectedNote();
    })();
  </script>

</body>

</html>